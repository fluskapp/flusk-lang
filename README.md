# flusk-lang

**YAML-first development language** â€” define your entire backend in YAML, generate production-ready Node.js + Python code.

> Write YAML. Ship code. No hallucinations.

[![Build](https://github.com/fluskapp/flusk-lang/actions/workflows/build.yml/badge.svg)](https://github.com/fluskapp/flusk-lang/actions)
[![License: MIT](https://img.shields.io/badge/License-MIT-blue.svg)](LICENSE)

## Why?

AI agents write code. AI agents also hallucinate, ignore rules, and fake generated markers.

**flusk-lang** solves this: agents can only write YAML, and the compiler generates deterministic code.

Same YAML â†’ same output. Every time. No exceptions.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  YAML    â”‚ â”€â”€â–¶ â”‚  flusk    â”‚ â”€â”€â–¶ â”‚  generated/node/ â”‚
â”‚  files   â”‚     â”‚  compiler â”‚     â”‚  generated/python/â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  source of        validate +         production-ready
  truth            build              code
```

## Quick Start

```bash
npm install @flusk/lang

# Validate your YAML schemas
npx flusk-lang validate

# Generate code
npx flusk-lang build
npx flusk-lang build --target node
npx flusk-lang build --target python
```

## YAML Types

### Entity â€” Data Models

Define your data with types, storage backend, and capabilities.

```yaml
name: AlertChannel
storage: postgres
fields:
  - name: name
    type: string
    required: true
    unique: true
  - name: channelType
    type: enum
    values: [slack, email, webhook]
  - name: enabled
    type: boolean
    default: true
capabilities: [crud, timestamps, soft-delete]
```

**Generates:** TypeBox schemas, TypeScript interfaces, repository interfaces, Pydantic models.

### Function â€” Business Logic

Define logic as composable steps. Steps can call functions, filter, forEach, map, and return values.

```yaml
name: dispatchAlert
inputs:
  - name: alert
    type: AlertEvent
  - name: db
    type: Database
output:
  type: DispatchResult[]
steps:
  - id: findChannels
    call: findEnabledAlertChannels
    with: { db: $db }
  - id: filtered
    action: filter
    source: $findChannels
    where: { field: severity, op: gte, value: $alert.severity }
  - id: send
    action: forEach
    source: $filtered
    call: sendToProvider
    with: { channel: $item, alert: $alert }
    onError: log-and-continue
```

**Generates:** Async TypeScript functions, async Python functions.

### Command â€” CLI Commands

```yaml
name: alerts-setup
description: Configure an alert channel
args:
  - name: name
    type: string
    required: true
options:
  - name: severity
    type: string
    default: warning
action:
  call: createAlertChannel
  with: { name: $name, severityFilter: $severity }
```

**Generates:** Commander.js CLI command files.

### Route â€” HTTP Endpoints

```yaml
name: alert-channels
basePath: /api/alert-channels
entity: AlertChannel
auth: required
operations:
  - method: GET
    path: /
    call: listAlertChannels
  - method: POST
    path: /
    call: createAlertChannel
    input: CreateAlertChannel
  - method: DELETE
    path: /:id
    call: deleteAlertChannel
```

**Generates:** Fastify route plugins with typed handlers.

### Provider â€” External Integrations

```yaml
name: slack
type: webhook
config:
  fields:
    - name: webhookUrl
      type: string
      required: true
methods:
  - name: send
    input: AlertEvent
    template: |
      {
        "text": "ğŸš¨ [{{severity}}] {{title}}",
        "blocks": [
          { "type": "header", "text": { "type": "plain_text", "text": "{{title}}" } }
        ]
      }
```

**Generates:** Provider classes with config interfaces and template rendering.

### Client â€” API Clients

```yaml
name: openai
baseUrl: https://api.openai.com/v1
auth:
  type: bearer
  envVar: OPENAI_API_KEY
endpoints:
  - name: createChatCompletion
    method: POST
    path: /chat/completions
    input:
      - name: model
        type: string
        required: true
      - name: messages
        type: json
        required: true
    output:
      type: ChatCompletion
    retry:
      maxAttempts: 3
      backoff: exponential
    timeout: 30000
```

**Generates:** Typed HTTP client classes with auth, retry logic, and timeout support.

## The Flow

```
YAML â†’ flusk-lang validate â†’ flusk-lang build â†’ generated/node/ + generated/python/
```

Every generated file includes `// @generated by flusk-lang â€” DO NOT EDIT` at the top. Your CI can grep for this marker to enforce the rule: **no hand-editing generated code.**

## CI Integration

```yaml
# .github/workflows/build.yml
name: Build
on: [push, pull_request]
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with: { node-version: 22 }
      - run: cd compiler && npm ci
      - run: cd compiler && npm run build
      - run: cd compiler && npm test
      - run: npx flusk-lang validate
      - run: npx flusk-lang build
      - run: git diff --exit-code generated/  # fail if generated code is stale
```

## Platformatic Integration

flusk-lang is designed to work alongside [Platformatic](https://platformatic.dev). Entity YAMLs generate Platformatic-compatible schemas and types. Routes generate Fastify plugins that run inside Platformatic services.

```
schema/entities/user.entity.yaml
  â†“ flusk-lang build
generated/node/src/entities/user.schema.ts    â†’ TypeBox schema (Platformatic DB)
generated/node/src/entities/user.types.ts     â†’ TypeScript types
generated/node/src/entities/user.repository.ts â†’ Repository interface

schema/routes/users.route.yaml
  â†“ flusk-lang build
generated/node/src/routes/users.routes.ts     â†’ Fastify plugin (autoloaded by Platformatic)
```

### Service â€” Standalone Infrastructure Services

Define proxy servers, collectors, and workers.

```yaml
name: llm-proxy
description: Transparent LLM API proxy
type: http-proxy
listen:
  port: 8787
  host: 0.0.0.0
upstream:
  providers:
    - name: openai
      baseUrl: https://api.openai.com
      detect: [/v1/chat/completions, /v1/embeddings]
middleware: [request-capture, cost-calculator]
streaming: true
```

### Middleware â€” Request/Response Interceptors

Define hooks that run in the request/response lifecycle.

```yaml
name: cost-calculator
description: Calculate LLM call cost
phase: response
inputs:
  - name: model
    from: response.model
  - name: inputTokens
    from: response.usage.prompt_tokens
output:
  costUsd: number
steps:
  - id: calculate
    action: assign
    value: computed
```

### Plugin â€” Fastify Plugins

Define reusable Fastify plugins with hooks and decorators.

```yaml
name: otel-capture
description: OpenTelemetry span capture
type: fastify-plugin
hooks:
  onRequest:
    - action: startSpan
      name: llm-call
decorators:
  - name: fluskCapture
    type: function
```

## Project Structure

```
schema/          â†’ YAML definitions (the source of truth)
  entities/      â†’ Data model definitions
  functions/     â†’ Business logic definitions
  commands/      â†’ CLI command definitions
  routes/        â†’ HTTP endpoint definitions
  providers/     â†’ External integration definitions
  clients/       â†’ API client definitions
  services/      â†’ Service definitions (proxy, server, worker)
  middlewares/   â†’ Middleware definitions (request/response hooks)
  plugins/       â†’ Plugin definitions (Fastify plugins)
compiler/        â†’ The flusk-lang compiler (TypeScript)
generated/       â†’ Output code (auto-generated, never hand-edit)
  node/          â†’ Generated Node.js/TypeScript code
  python/        â†’ Generated Python code
examples/        â†’ Example YAML definitions for all types
```

## Philosophy

- **YAML is the source of truth** â€” code is a build artifact
- **Deterministic** â€” same input = same output, always
- **Multi-target** â€” Node.js + Python from the same definitions
- **AI-safe** â€” agents write YAML, humans review YAML, machines generate code
- **Composable** â€” entities reference entities, functions call functions
- **Minimal** â€” two dependencies (ajv + js-yaml), zero runtime overhead

## Demos

5 complete projects proving ANY backend can be defined in YAML and generate clean code.

**77 YAMLs â†’ 107 generated files â†’ 1,700+ lines â†’ 0 lint errors**

| Demo | Entities | Functions | Commands | Routes | Events | Workers | Streams | Clients | Generated Files |
|------|----------|-----------|----------|--------|--------|---------|---------|---------|-----------------|
| Video Processing Pipeline | 2 | 3 | 2 | 1 | 2 | 1 | â€” | 2 | 17 |
| Real-time Analytics | 3 | 3 | â€” | 2 | 1 | â€” | 2 | â€” | 17 |
| AI Agent Orchestrator | 3 | 4 | 2 | 2 | 2 | 1 | 1 | 3 | 24 |
| IoT Sensor Platform | 3 | 3 | 2 | 3 | 2 | 1 | 1 | â€” | 21 |
| E-commerce Orders | 4 | 4 | 2 | 3 | 3 | 2 | â€” | 2 | 28 |

Each demo lives in `examples/demos/` with full YAML schemas covering entities, functions, commands, routes, events, workers, streams, and clients.

## License

MIT Â© [Flusk](https://github.com/fluskapp)
