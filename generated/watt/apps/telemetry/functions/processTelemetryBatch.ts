// @generated by flusk-lang logic compiler
import type { FastifyInstance, FastifyRequest, FastifyReply } from 'fastify';

// now() = new Date().toISOString()

interface ProcessTelemetryBatchInput {
  spans: unknown[];
  orgId: number;
  deviceId: string;
}

export default async function processTelemetryBatch(
  app: FastifyInstance,
  request: FastifyRequest,
  reply: FastifyReply,
  input: ProcessTelemetryBatchInput,
) {
  const results = [];
  for (const span of input.spans) {
    const provider = (span.attributes.gen_ai_system ?? 'unknown');
    const model = (span.attributes.gen_ai_request_model ?? 'unknown');
    const input_tokens = (span.attributes.gen_ai_usage_input_tokens ?? 0);
    const output_tokens = (span.attributes.gen_ai_usage_output_tokens ?? 0);
    const latency_ms = (span.duration ?? 0);
    const tool = await app.platformatic.entities.aiTool.find({ where: { org_id: input.org_id, name: provider }, limit: 1 }).then(r => r[0] ?? null);
    if (!(tool)) {
      const tool = await app.platformatic.entities.aiTool.save({ input: { org_id: input.org_id, name: provider, provider, category: 'other', approved: false, first_seen_at: new Date().toISOString(), last_seen_at: new Date().toISOString() } });
      app.emit('newToolDetected', { org_id: input.org_id, tool_name: provider, provider: provider });
    }
    const is_approved = tool.approved;
    if (!(is_approved)) {
      app.emit('shadowAiDetected', { org_id: input.org_id, device_id: input.device_id, tool_name: provider, provider: provider });
    }
    const cost_usd = input_tokens * 0.000003 + output_tokens * 0.000015;
    await app.platformatic.entities.telemetryEvent.save({ input: { org_id: input.org_id, device_id: input.device_id, trace_id: span.traceId, span_id: span.spanId, provider: provider, model: model, input_tokens: input_tokens, output_tokens: output_tokens, latency_ms: latency_ms, cost_usd: cost_usd, is_approved: is_approved } });
  }
  return reply.send({ processed: input.spans.length });
}
