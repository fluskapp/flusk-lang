const HEADER_PREFIX = '// @generated by flusk-lang';
const MAX_LINES = 100;

export interface LintIssue {
  rule: string;
  message: string;
  line?: number;
}

export interface LintResult {
  file: string;
  issues: LintIssue[];
  passed: boolean;
}

const checkNoAny = (code: string): LintIssue[] => {
  const issues: LintIssue[] = [];
  const lines = code.split('\n');
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    if (/:\s*any\b/.test(line) || /\bas\s+any\b/.test(line)) {
      issues.push({ rule: 'no-explicit-any', message: `Found "any" type`, line: i + 1 });
    }
    if (/Type\.Any\(\)/.test(line)) {
      issues.push({ rule: 'no-explicit-any', message: `Found Type.Any()`, line: i + 1 });
    }
  }
  return issues;
};

const checkFileLength = (code: string): LintIssue[] => {
  const count = code.split('\n').length;
  if (count > MAX_LINES) {
    return [{ rule: 'max-lines', message: `File has ${count} lines (max ${MAX_LINES})` }];
  }
  return [];
};

const checkHeader = (code: string): LintIssue[] => {
  if (!code.startsWith(HEADER_PREFIX)) {
    return [{ rule: 'generated-header', message: `Missing @generated header` }];
  }
  return [];
};

const checkNoDefaultExport = (code: string): LintIssue[] => {
  const issues: LintIssue[] = [];
  const lines = code.split('\n');
  for (let i = 0; i < lines.length; i++) {
    if (/^export\s+default\b/.test(lines[i])) {
      issues.push({ rule: 'named-exports-only', message: `Found export default`, line: i + 1 });
    }
  }
  return issues;
};

const checkUnusedImports = (code: string): LintIssue[] => {
  const issues: LintIssue[] = [];
  const lines = code.split('\n');
  const importRegex = /^import\s+(?:type\s+)?(?:\{([^}]+)\}|(\w+))\s+from/;
  for (let i = 0; i < lines.length; i++) {
    const match = importRegex.exec(lines[i]);
    if (!match) continue;
    const names = match[1]
      ? match[1].split(',').map((n) => n.trim().split(/\s+as\s+/).pop()!.trim()).filter(Boolean)
      : match[2] ? [match[2]] : [];
    const body = lines.slice(i + 1).join('\n');
    for (const name of names) {
      const escaped = name.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
      if (!new RegExp(`\\b${escaped}\\b`).test(body)) {
        issues.push({ rule: 'no-unused-imports', message: `Import "${name}" is unused`, line: i + 1 });
      }
    }
  }
  return issues;
};

const checkUnusedVars = (code: string): LintIssue[] => {
  const issues: LintIssue[] = [];
  const lines = code.split('\n');
  const declRegex = /^\s*(?:export\s+)?(?:const|let|function)\s+(\w+)/;
  for (let i = 0; i < lines.length; i++) {
    const match = declRegex.exec(lines[i]);
    if (!match) continue;
    const name = match[1];
    const before = lines.slice(0, i).join('\n');
    const after = lines.slice(i + 1).join('\n');
    const escaped = name.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    const re = new RegExp(`\\b${escaped}\\b`);
    // Check if referenced elsewhere (after declaration or in an export)
    if (!re.test(after) && !re.test(before)) {
      issues.push({ rule: 'no-unused-vars', message: `"${name}" is declared but never used`, line: i + 1 });
    }
  }
  return issues;
};

export const lintGeneratedCode = (file: string, code: string): LintResult => {
  const issues = [
    ...checkHeader(code),
    ...checkNoAny(code),
    ...checkFileLength(code),
    ...checkNoDefaultExport(code),
    ...checkUnusedImports(code),
    ...checkUnusedVars(code),
  ];
  return { file, issues, passed: issues.length === 0 };
};
