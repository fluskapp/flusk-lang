import type { FunctionDef, FunctionStep } from '../../parsers/function.parser.js';

const HEADER = '// @generated by flusk-lang â€” DO NOT EDIT\n';

const generateStepCode = (step: FunctionStep, indent: string): string => {
  const lines: string[] = [];

  if (step.call && !step.action) {
    const args = step.with
      ? Object.entries(step.with).map(([, v]) => v.startsWith('$') ? v.slice(1) : `'${v}'`).join(', ')
      : '';
    lines.push(`${indent}const ${step.id} = await ${step.call}(${args});`);
  } else if (step.action === 'filter' && step.where) {
    const src = step.source?.startsWith('$') ? step.source.slice(1) : step.source;
    const val = String(step.where.value);
    const valExpr = val.startsWith('$') ? val.slice(1) : `'${val}'`;
    const opMap: Record<string, string> = {
      eq: '===', neq: '!==', gt: '>', gte: '>=', lt: '<', lte: '<=',
    };
    const op = opMap[step.where.op] ?? '===';
    lines.push(`${indent}const ${step.id} = ${src}.filter((item) => item.${step.where.field} ${op} ${valExpr});`);
  } else if (step.action === 'forEach') {
    const src = step.source?.startsWith('$') ? step.source.slice(1) : step.source;
    const args = step.with
      ? Object.entries(step.with).map(([, v]) => {
          if (v === '$item') return 'item';
          return v.startsWith('$') ? v.slice(1) : `'${v}'`;
        }).join(', ')
      : 'item';
    const errHandler = step.onError === 'log-and-continue'
      ? `\n${indent}    } catch (err) {\n${indent}      console.error(err);\n${indent}    }`
      : `\n${indent}    } catch (err) {\n${indent}      throw err;\n${indent}    }`;
    lines.push(`${indent}for (const item of ${src}) {`);
    lines.push(`${indent}    try {`);
    lines.push(`${indent}      await ${step.call}(${args});`);
    lines.push(errHandler);
    lines.push(`${indent}}`);
  } else if (step.action === 'return') {
    const val = step.source?.startsWith('$') ? step.source.slice(1) : step.source;
    lines.push(`${indent}return ${val};`);
  } else {
    lines.push(`${indent}// TODO: implement action "${step.action}" for step "${step.id}"`);
  }

  return lines.join('\n');
};

export const generateFunction = (fn: FunctionDef): string => {
  const lines = [HEADER];
  const params = (fn.inputs ?? []).map((i) => `${i.name}: ${i.type}`).join(', ');
  const returnType = fn.output?.type ?? 'void';
  lines.push(`export const ${fn.name} = async (${params}): Promise<${returnType}> => {`);

  for (const step of fn.steps) {
    lines.push(generateStepCode(step, '  '));
  }

  lines.push(`};\n`);
  return lines.join('\n');
};
