import type { FunctionDef, FunctionStep } from '../../parsers/function.parser.js';

const HEADER = '// @generated by flusk-lang — DO NOT EDIT\n';

/**
 * Resolve a value from YAML into a JS expression.
 * - "$foo" → foo
 * - "$foo.bar" → foo.bar
 * - plain string → 'string'
 * - objects/arrays → JSON-like inline
 */
const resolveValue = (val: unknown): string => {
  if (typeof val === 'string') {
    if (val.startsWith('$')) return val.slice(1);
    return `'${val}'`;
  }
  if (typeof val === 'number' || typeof val === 'boolean') return String(val);
  if (val === null || val === undefined) return 'undefined';
  if (Array.isArray(val)) {
    return `[${val.map(resolveValue).join(', ')}]`;
  }
  if (typeof val === 'object') {
    const entries = Object.entries(val as Record<string, unknown>)
      .map(([k, v]) => `${k}: ${resolveValue(v)}`);
    return `{ ${entries.join(', ')} }`;
  }
  return String(val);
};

/**
 * Check if a call is an Entity.method pattern (Platformatic DB operation)
 */
const isEntityCall = (call: string): boolean => {
  const dot = call.indexOf('.');
  if (dot === -1) return false;
  const entity = call.slice(0, dot);
  return /^[A-Z]/.test(entity);
};

/**
 * Map Entity.method to Platformatic REST call.
 *
 * Platformatic DB exposes:
 *   GET    /{entity}          → findMany (with query params)
 *   GET    /{entity}/:id      → findOne
 *   POST   /{entity}          → create
 *   PUT    /{entity}/:id      → update
 *   DELETE /{entity}/:id      → delete
 *   GET    /{entity}/count    → count (custom, or use findMany + length)
 */
const generateEntityCallCode = (step: FunctionStep, indent: string): string => {
  const lines: string[] = [];
  const call = step.call!;
  const dot = call.indexOf('.');
  const entity = call.slice(0, dot);
  const method = call.slice(dot + 1);
  const entityPath = entity.charAt(0).toLowerCase() + entity.slice(1);

  // Build the with params
  const params = step.with ?? {};

  switch (method) {
    case 'findMany': {
      const where = params.where ? resolveValue(params.where) : '{}';
      const orderBy = params.orderBy ? resolveValue(params.orderBy) : undefined;
      const limit = params.limit ? resolveValue(params.limit) : undefined;
      const search = params.search ? resolveValue(params.search) : undefined;
      lines.push(`${indent}const ${step.id} = await platformatic.entities.${entityPath}.find({`);
      lines.push(`${indent}  where: ${where},`);
      if (orderBy) lines.push(`${indent}  orderBy: ${orderBy},`);
      if (limit) lines.push(`${indent}  limit: ${limit},`);
      if (search) lines.push(`${indent}  search: ${search},`);
      lines.push(`${indent}});`);
      break;
    }
    case 'findOne': {
      const where = params.where ? resolveValue(params.where) : '{}';
      lines.push(`${indent}const ${step.id} = await platformatic.entities.${entityPath}.find({`);
      lines.push(`${indent}  where: ${where},`);
      lines.push(`${indent}  limit: 1,`);
      lines.push(`${indent}}).then((r: any[]) => r[0]);`);
      break;
    }
    case 'create': {
      // All with params except 'where' are the fields to create
      const fields = Object.entries(params)
        .filter(([k]) => k !== 'where')
        .map(([k, v]) => `${k}: ${resolveValue(v)}`)
        .join(', ');
      lines.push(`${indent}const ${step.id} = await platformatic.entities.${entityPath}.save({`);
      lines.push(`${indent}  input: { ${fields} },`);
      lines.push(`${indent}});`);
      break;
    }
    case 'update': {
      const where = params.where ? resolveValue(params.where) : '{}';
      const data = params.data ? resolveValue(params.data) : '{}';
      lines.push(`${indent}const ${step.id} = await platformatic.entities.${entityPath}.save({`);
      lines.push(`${indent}  where: ${where},`);
      lines.push(`${indent}  input: ${data},`);
      lines.push(`${indent}});`);
      break;
    }
    case 'delete': {
      const where = params.where ? resolveValue(params.where) : '{}';
      lines.push(`${indent}const ${step.id} = await platformatic.entities.${entityPath}.delete({`);
      lines.push(`${indent}  where: ${where},`);
      lines.push(`${indent}});`);
      break;
    }
    case 'count': {
      const where = params.where ? resolveValue(params.where) : '{}';
      lines.push(`${indent}const ${step.id} = await platformatic.entities.${entityPath}.count({`);
      lines.push(`${indent}  where: ${where},`);
      lines.push(`${indent}});`);
      break;
    }
    case 'aggregate': {
      const where = params.where ? resolveValue(params.where) : '{}';
      const sum = params.sum ? resolveValue(params.sum) : undefined;
      const groupBy = params.groupBy ? resolveValue(params.groupBy) : undefined;
      lines.push(`${indent}const ${step.id} = await platformatic.entities.${entityPath}.find({`);
      lines.push(`${indent}  where: ${where},`);
      lines.push(`${indent}}).then((rows: any[]) => {`);
      if (groupBy && sum) {
        lines.push(`${indent}  const groups: Record<string, number> = {};`);
        lines.push(`${indent}  for (const row of rows) { groups[row[${groupBy}]] = (groups[row[${groupBy}]] ?? 0) + (row[${sum}] ?? 0); }`);
        lines.push(`${indent}  return groups;`);
      } else if (sum) {
        lines.push(`${indent}  return rows.reduce((acc, row) => acc + (row[${sum}] ?? 0), 0);`);
      } else if (groupBy) {
        lines.push(`${indent}  const groups: Record<string, any[]> = {};`);
        lines.push(`${indent}  for (const row of rows) { (groups[row[${groupBy}]] ??= []).push(row); }`);
        lines.push(`${indent}  return Object.entries(groups).map(([key, items]) => ({ key, count: items.length }));`);
      } else {
        lines.push(`${indent}  return rows;`);
      }
      lines.push(`${indent}});`);
      break;
    }
    default:
      lines.push(`${indent}// TODO: unknown entity method "${method}" on "${entity}"`);
  }

  return lines.join('\n');
};

const generateStepCode = (step: FunctionStep, indent: string): string => {
  const lines: string[] = [];

  // Entity.method → Platformatic DB call
  if (step.call && isEntityCall(step.call)) {
    return generateEntityCallCode(step, indent);
  }

  if (step.call && !step.action) {
    const args = step.with
      ? Object.entries(step.with).map(([, v]) => resolveValue(v)).join(', ')
      : '';
    lines.push(`${indent}const ${step.id} = await ${step.call}(${args});`);
  } else if (step.action === 'filter' && step.where) {
    const src = step.source?.startsWith('$') ? step.source.slice(1) : step.source;
    const val = String(step.where.value);
    const valExpr = val.startsWith('$') ? val.slice(1) : `'${val}'`;
    const opMap: Record<string, string> = {
      eq: '===', neq: '!==', gt: '>', gte: '>=', lt: '<', lte: '<=',
    };
    const op = opMap[step.where.op] ?? '===';
    lines.push(`${indent}const ${step.id} = ${src}.filter((item) => item.${step.where!.field} ${op} ${valExpr});`);
  } else if (step.action === 'forEach') {
    const src = step.source?.startsWith('$') ? step.source.slice(1) : step.source;
    const args = step.with
      ? Object.entries(step.with).map(([, v]) => {
          if (v === '$item') return 'item';
          return resolveValue(v);
        }).join(', ')
      : 'item';
    const errHandler = step.onError === 'log-and-continue'
      ? `\n${indent}    } catch (err) {\n${indent}      console.error(err);\n${indent}    }`
      : `\n${indent}    } catch (err) {\n${indent}      throw err;\n${indent}    }`;
    lines.push(`${indent}for (const item of ${src}) {`);
    lines.push(`${indent}    try {`);
    lines.push(`${indent}      await ${step.call}(${args});`);
    lines.push(errHandler);
    lines.push(`${indent}}`);
  } else if (step.action === 'return') {
    if (step.with) {
      const obj = Object.entries(step.with)
        .map(([k, v]) => `${k}: ${resolveValue(v)}`).join(', ');
      lines.push(`${indent}return { ${obj} };`);
    } else {
      const val = step.source?.startsWith('$') ? step.source.slice(1) : step.source;
      lines.push(`${indent}return ${val};`);
    }
  } else if (step.action === 'transform') {
    const src = step.with?.source ? resolveValue(step.with.source) : step.with?.template ? resolveValue(step.with.template) : 'undefined';
    lines.push(`${indent}const ${step.id} = ${src};`);
  } else if (step.action === 'condition') {
    const cond = step.with?.if ? resolveValue(step.with.if) : 'false';
    lines.push(`${indent}let ${step.id} = undefined;`);
    lines.push(`${indent}if (${cond}) {`);
    if (step.with?.then && typeof step.with.then === 'object') {
      const thenBlock = step.with.then as Record<string, unknown>;
      if (thenBlock.call) {
        const args = thenBlock.with
          ? Object.entries(thenBlock.with as Record<string, unknown>)
              .map(([, v]) => resolveValue(v)).join(', ')
          : '';
        lines.push(`${indent}  ${step.id} = await ${thenBlock.call}(${args});`);
      }
    }
    lines.push(`${indent}}`);
  } else if (step.action === 'assign') {
    if (step.with) {
      const entries = Object.entries(step.with);
      for (const [k, v] of entries) {
        lines.push(`${indent}const ${k} = ${resolveValue(v)};`);
      }
    }
    lines.push(`${indent}const ${step.id} = undefined; // assign`);
  } else {
    lines.push(`${indent}// TODO: implement action "${step.action}" for step "${step.id}"`);
  }

  return lines.join('\n');
};

export const generateFunction = (fn: FunctionDef): string => {
  const lines = [HEADER];
  const params = (fn.inputs ?? []).map((i) => `${i.name}: ${i.type}`).join(', ');
  const returnType = fn.output?.type ?? 'void';
  lines.push(`export const ${fn.name} = async (platformatic: any, ${params}): Promise<${returnType}> => {`);

  for (const step of fn.steps) {
    lines.push(generateStepCode(step, '  '));
  }

  lines.push(`};\n`);
  return lines.join('\n');
};
