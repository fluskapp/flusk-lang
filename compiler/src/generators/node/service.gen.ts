import type { ServiceDef } from '../../parsers/service.parser.js';

const HEADER = '// @generated by flusk-lang â€” DO NOT EDIT\n';

const camelCase = (s: string): string => s.replace(/-([a-z])/g, (_, c) => c.toUpperCase());

const generateProviderDetection = (def: ServiceDef): string[] => {
  const lines: string[] = [];
  if (!def.upstream?.providers?.length) return lines;
  lines.push(`const detectProvider = (path: string): string | null => {`);
  for (const p of def.upstream.providers) {
    if (p.detect?.length) {
      const paths = p.detect.map((d) => `'${d}'`).join(', ');
      lines.push(`  if ([${paths}].some((p) => path.startsWith(p))) return '${p.name}';`);
    }
  }
  lines.push(`  return null;`, `};\n`);
  return lines;
};

const generateUpstreamMap = (def: ServiceDef): string[] => {
  if (!def.upstream?.providers?.length) return [];
  const lines = [`const upstreams: Record<string, string> = {`];
  for (const p of def.upstream.providers) lines.push(`  '${p.name}': '${p.baseUrl}',`);
  lines.push(`};\n`);
  return lines;
};

export const generateService = (def: ServiceDef): string => {
  const lines = [HEADER, `import Fastify from 'fastify';\n`];
  const fnName = camelCase(def.name);
  lines.push(...generateProviderDetection(def));
  lines.push(...generateUpstreamMap(def));
  lines.push(`export const ${fnName}Server = async (): Promise<void> => {`);
  lines.push(`  const app = Fastify({ logger: true });`);
  if (def.middleware?.length) {
    for (const mw of def.middleware) {
      lines.push(`  app.addHook('onRequest', ${camelCase(mw)});`);
    }
  }
  if (def.type === 'http-proxy' && def.upstream?.providers?.length) {
    lines.push(`  app.all('/*', async (request, reply) => {`);
    lines.push(`    const provider = detectProvider(request.url);`);
    lines.push(`    if (!provider) return reply.code(404).send({ error: 'Unknown route' });`);
    lines.push(`    const upstream = upstreams[provider];`);
    if (def.streaming) {
      lines.push(`    const res = await fetch(upstream + request.url, {`);
      lines.push(`      method: request.method, headers: request.headers as Record<string, string>,`);
      lines.push(`      body: request.method !== 'GET' ? JSON.stringify(request.body) : undefined,`);
      lines.push(`    });`);
      lines.push(`    reply.raw.writeHead(res.status, Object.fromEntries(res.headers));`);
      lines.push(`    if (res.body) for await (const chunk of res.body) reply.raw.write(chunk);`);
      lines.push(`    reply.raw.end();`);
    } else {
      lines.push(`    const res = await fetch(upstream + request.url, {`);
      lines.push(`      method: request.method, headers: request.headers as Record<string, string>,`);
      lines.push(`      body: request.method !== 'GET' ? JSON.stringify(request.body) : undefined,`);
      lines.push(`    });`);
      lines.push(`    reply.code(res.status).send(await res.json());`);
    }
    lines.push(`  });`);
  }
  const host = def.listen.host ?? '0.0.0.0';
  lines.push(`  await app.listen({ port: ${def.listen.port}, host: '${host}' });`);
  lines.push(`};\n`);
  return lines.join('\n');
};
