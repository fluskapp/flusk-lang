import type { EntityDef, EntityField } from '../../parsers/entity.parser.js';

const HEADER = '// @generated by flusk-lang â€” DO NOT EDIT\n';

const mapType = (field: EntityField): string => {
  const types: Record<string, string> = {
    string: 'Type.String()',
    number: 'Type.Number()',
    boolean: 'Type.Boolean()',
    date: 'Type.String({ format: "date-time" })',
    json: 'Type.Record(Type.String(), Type.Unknown())',
  };
  if (field.type === 'enum' && field.values) {
    return `Type.Union([${field.values.map((v) => `Type.Literal('${v}')`).join(', ')}])`;
  }
  return types[field.type] ?? 'Type.Unknown()';
};

const mapTsType = (field: EntityField): string => {
  const types: Record<string, string> = {
    string: 'string', number: 'number', boolean: 'boolean',
    date: 'string', json: 'Record<string, unknown>',
  };
  if (field.type === 'enum' && field.values) return field.values.map((v) => `'${v}'`).join(' | ');
  return types[field.type] ?? 'unknown';
};

export const generateEntitySchema = (entity: EntityDef): string => {
  const lines = [HEADER, `import { Type, Static } from '@sinclair/typebox';\n`];
  lines.push(`export const ${entity.name}Schema = Type.Object({`);
  lines.push(`  id: Type.String(),`);
  for (const f of entity.fields) {
    const typeExpr = f.required === false ? `Type.Optional(${mapType(f)})` : mapType(f);
    lines.push(`  ${f.name}: ${typeExpr},`);
  }
  lines.push(`  createdAt: Type.String({ format: "date-time" }),`);
  lines.push(`  updatedAt: Type.String({ format: "date-time" }),`);
  lines.push(`});\n`);
  lines.push(`export type ${entity.name} = Static<typeof ${entity.name}Schema>;\n`);
  return lines.join('\n');
};

export const generateEntityType = (entity: EntityDef): string => {
  const lines = [HEADER];
  lines.push(`export interface ${entity.name} {`);
  lines.push(`  id: string;`);
  for (const f of entity.fields) {
    const opt = f.required === false ? '?' : '';
    lines.push(`  ${f.name}${opt}: ${mapTsType(f)};`);
  }
  lines.push(`  createdAt: string;`);
  lines.push(`  updatedAt: string;`);
  lines.push(`}\n`);
  return lines.join('\n');
};

export const generateEntityRepository = (entity: EntityDef): string => {
  const name = entity.name;
  const lines = [HEADER];
  lines.push(`import type { ${name} } from './${name.toLowerCase()}.types.js';\n`);
  lines.push(`export interface ${name}Repository {`);
  lines.push(`  findById(id: string): Promise<${name} | null>;`);
  lines.push(`  findAll(): Promise<${name}[]>;`);
  lines.push(`  create(data: Omit<${name}, 'id'>): Promise<${name}>;`);
  lines.push(`  update(id: string, data: Partial<${name}>): Promise<${name}>;`);
  lines.push(`  delete(id: string): Promise<void>;`);
  lines.push(`}\n`);
  return lines.join('\n');
};
