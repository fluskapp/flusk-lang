import type { HookDef } from '../../parsers/hook.parser.js';

const HEADER = '// @generated by flusk-lang â€” DO NOT EDIT\n';

/** Map flusk-lang lifecycle events to Platformatic entity hook names */
const HOOK_MAP: Record<string, string> = {
  preSave: 'save',
  postSave: 'afterSave',
  preDelete: 'delete',
  postDelete: 'afterDelete',
  preFind: 'find',
  postFind: 'afterFind',
};

const isPreHook = (event: string): boolean =>
  event.startsWith('pre');

export const generateHook = (hook: HookDef): string => {
  const lines = [HEADER];
  const entityVar = hook.entity.charAt(0).toLowerCase() + hook.entity.slice(1);

  lines.push(`import type { FastifyInstance } from 'fastify';\n`);
  lines.push(`/** ${hook.description ?? hook.name} */`);
  lines.push(`export const register${hook.name.charAt(0).toUpperCase() + hook.name.slice(1)}Hooks = (app: FastifyInstance): void => {`);
  lines.push(`  const entity = app.platformatic.entities.${entityVar};\n`);

  for (const lc of hook.lifecycle) {
    const platformaticHook = HOOK_MAP[lc.event] ?? lc.event;
    const callFn = lc.call ?? `handle${lc.event.charAt(0).toUpperCase() + lc.event.slice(1)}`;
    const withArgs = lc.with
      ? ', ' + JSON.stringify(lc.with)
      : '';

    if (isPreHook(lc.event)) {
      // Pre-hooks receive (original, { input, ... }) and must return the modified input
      lines.push(`  entity.addHook('${platformaticHook}', async (original, context) => {`);
      lines.push(`    await ${callFn}(context${withArgs});`);
      lines.push(`    return original(context);`);
      lines.push(`  });\n`);
    } else {
      // Post-hooks receive the result
      lines.push(`  entity.addHook('${platformaticHook}', async (result, context) => {`);
      lines.push(`    await ${callFn}(result, context${withArgs});`);
      lines.push(`    return result;`);
      lines.push(`  });\n`);
    }
  }

  lines.push(`};\n`);
  return lines.join('\n');
};
