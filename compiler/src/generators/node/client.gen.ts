import type { ClientDef, ClientEndpoint } from '../../parsers/client.parser.js';

const HEADER = '// @generated by flusk-lang â€” DO NOT EDIT\n';

const pascalCase = (s: string): string => s.charAt(0).toUpperCase() + s.slice(1);

const mapType = (type: string): string => {
  const m: Record<string, string> = {
    string: 'string', number: 'number', boolean: 'boolean', json: 'unknown',
  };
  return m[type] ?? type;
};

const genInputInterface = (ep: ClientEndpoint, prefix: string): string => {
  if (!ep.input?.length) return '';
  const lines = [`export interface ${prefix}${pascalCase(ep.name)}Input {`];
  for (const i of ep.input) {
    const opt = i.required ? '' : '?';
    lines.push(`  ${i.name}${opt}: ${mapType(i.type)};`);
  }
  lines.push('}\n');
  return lines.join('\n');
};

const genAuthSetup = (def: ClientDef): string => {
  if (!def.auth) return '';
  const v = `process.env[${JSON.stringify(def.auth.envVar)}] ?? ''`;
  if (def.auth.type === 'bearer') {
    return `    headers['Authorization'] = \`Bearer \${${v}}\`;`;
  }
  if (def.auth.type === 'header') {
    const h = def.auth.headerName ?? 'X-API-Key';
    return `    headers[${JSON.stringify(h)}] = ${v};`;
  }
  return '';
};

const genMethod = (ep: ClientEndpoint, def: ClientDef): string => {
  const prefix = pascalCase(def.name);
  const hasInput = !!ep.input?.length;
  const param = hasInput ? `input: ${prefix}${pascalCase(ep.name)}Input` : '';
  const retType = ep.output?.type ?? 'unknown';
  const timeout = ep.timeout ?? 30000;
  const retry = ep.retry?.maxAttempts ?? 1;
  const lines: string[] = [];
  lines.push(`  async ${ep.name}(${param}): Promise<${retType}> {`);
  lines.push(`    const url = \`\${this.baseUrl}${ep.path}\`;`);
  if (hasInput && ep.method !== 'GET') {
    lines.push(`    const body = JSON.stringify(input);`);
  }
  lines.push(`    return this.request('${ep.method}', url, {`);
  if (hasInput && ep.method !== 'GET') lines.push(`      body,`);
  lines.push(`      timeout: ${timeout}, maxAttempts: ${retry},`);
  lines.push(`    });`);
  lines.push(`  }\n`);
  return lines.join('\n');
};

export const generateClient = (def: ClientDef): string => {
  const prefix = pascalCase(def.name);
  const lines = [HEADER];

  for (const ep of def.endpoints) {
    const iface = genInputInterface(ep, prefix);
    if (iface) lines.push(iface);
  }

  lines.push(`export class ${prefix}Client {`);
  lines.push(`  constructor(private readonly baseUrl = ${JSON.stringify(def.baseUrl)}) {}\n`);

  lines.push(`  private async request(method: string, url: string, opts: {`);
  lines.push(`    body?: string; timeout: number; maxAttempts: number;`);
  lines.push(`  }): Promise<any> {`);
  lines.push(`    const headers: Record<string, string> = { 'Content-Type': 'application/json' };`);
  const auth = genAuthSetup(def);
  if (auth) lines.push(auth);
  lines.push(`    let lastError: Error | null = null;`);
  lines.push(`    for (let i = 0; i < opts.maxAttempts; i++) {`);
  lines.push(`      try {`);
  lines.push(`        const res = await fetch(url, {`);
  lines.push(`          method, headers, body: opts.body,`);
  lines.push(`          signal: AbortSignal.timeout(opts.timeout),`);
  lines.push(`        });`);
  lines.push(`        if (!res.ok) throw new Error(\`\${res.status} \${res.statusText}\`);`);
  lines.push(`        return await res.json();`);
  lines.push(`      } catch (err) {`);
  lines.push(`        lastError = err as Error;`);
  lines.push(`        if (i < opts.maxAttempts - 1) await new Promise(r => setTimeout(r, 2 ** i * 1000));`);
  lines.push(`      }`);
  lines.push(`    }`);
  lines.push(`    throw lastError;`);
  lines.push(`  }\n`);

  for (const ep of def.endpoints) {
    lines.push(genMethod(ep, def));
  }

  lines.push('}\n');
  return lines.join('\n');
};
