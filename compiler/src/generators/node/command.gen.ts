import type { CommandDef } from '../../parsers/command.parser.js';

const HEADER = '// @generated by flusk-lang â€” DO NOT EDIT\n';

export const generateCommand = (cmd: CommandDef): string => {
  const lines = [HEADER];
  lines.push(`import { Command } from 'commander';\n`);
  lines.push(`export const ${cmd.name.replace(/-([a-z])/g, (_, c) => c.toUpperCase())}Command = new Command('${cmd.name}')`);

  if (cmd.description) {
    lines.push(`  .description(${JSON.stringify(cmd.description)})`);
  }

  for (const arg of cmd.args ?? []) {
    const bracket = arg.required ? `<${arg.name}>` : `[${arg.name}]`;
    const desc = arg.description ?? arg.name;
    lines.push(`  .argument('${bracket}', ${JSON.stringify(desc)})`);
  }

  for (const opt of cmd.options ?? []) {
    const flag = `--${opt.name} <${opt.name}>`;
    const desc = opt.description ?? opt.name;
    if (opt.default !== undefined) {
      lines.push(`  .option('${flag}', ${JSON.stringify(desc)}, ${JSON.stringify(opt.default)})`);
    } else {
      lines.push(`  .option('${flag}', ${JSON.stringify(desc)})`);
    }
  }

  const argNames = (cmd.args ?? []).map((a) => a.name);
  const params = [...argNames, 'options'].join(', ');
  lines.push(`  .action(async (${params}) => {`);

  const withEntries = Object.entries(cmd.action.with ?? {});
  if (withEntries.length) {
    lines.push(`    await ${cmd.action.call}({`);
    for (const [key, val] of withEntries) {
      const v = val.startsWith('$') ? val.slice(1) : `'${val}'`;
      const src = argNames.includes(v) ? v : `options.${v}`;
      lines.push(`      ${key}: ${argNames.includes(v) ? v : src},`);
    }
    lines.push(`    });`);
  } else {
    lines.push(`    await ${cmd.action.call}();`);
  }

  lines.push(`  });\n`);
  return lines.join('\n');
};
