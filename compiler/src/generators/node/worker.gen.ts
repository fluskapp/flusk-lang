import type { WorkerDef } from '../../parsers/worker.parser.js';

const HEADER = '// @generated by flusk-lang â€” DO NOT EDIT\n';

const camelCase = (s: string): string =>
  s.charAt(0).toLowerCase() + s.slice(1);

const genStepCode = (step: { id: string; call?: string; action?: string; with?: Record<string, string> }): string => {
  if (step.call && !step.action) {
    const args = step.with
      ? Object.values(step.with).map((v) => v.startsWith('$') ? v.slice(1) : `'${v}'`).join(', ')
      : '';
    return `    const ${step.id} = await ${step.call}(${args});`;
  }
  if (step.action === 'return') return `    return ${step.id};`;
  return `    // TODO: implement step "${step.id}"`;
};

export const generateWorker = (def: WorkerDef): string => {
  const lines = [HEADER];
  const fnName = camelCase(def.name);

  if (def.type === 'bullmq') {
    const queue = def.queue ?? camelCase(def.name);
    lines.push(`export const ${fnName}Queue = '${queue}';\n`);
    lines.push(`export const ${fnName}Handler = async (job: { data: Record<string, unknown> }): Promise<void> => {`);
    lines.push(`  const { data } = job;`);
  } else if (def.type === 'temporal-workflow') {
    const taskQueue = def.taskQueue ?? camelCase(def.name);
    lines.push(`export const ${fnName}TaskQueue = '${taskQueue}';\n`);
    lines.push(`export const ${fnName}Workflow = async (input: Record<string, unknown>): Promise<void> => {`);
  } else {
    lines.push(`export const ${fnName}Schedule = '${def.schedule ?? '* * * * *'}';\n`);
    lines.push(`export const ${fnName}Job = async (): Promise<void> => {`);
  }

  for (const step of def.steps ?? []) {
    lines.push(genStepCode(step));
  }

  if (def.retry) {
    lines.push(`  // Retry config: maxAttempts=${def.retry.maxAttempts}, backoff=${def.retry.backoff}`);
  }

  lines.push(`};\n`);
  return lines.join('\n');
};
