import type { EntityDef, EntityField } from '../../parsers/entity.parser.js';

const HEADER = '# @generated by flusk-lang â€” DO NOT EDIT\n';

const mapPythonType = (field: EntityField): string => {
  const types: Record<string, string> = {
    string: 'str', number: 'int', boolean: 'bool',
    date: 'datetime', json: 'dict[str, Any]',
  };
  if (field.type === 'enum' && field.values) {
    return `Literal[${field.values.map((v) => `"${v}"`).join(', ')}]`;
  }
  return types[field.type] ?? 'Any';
};

export const generatePythonEntity = (entity: EntityDef): string => {
  const lines = [HEADER];
  const imports = new Set<string>(['from __future__ import annotations']);
  imports.add('from pydantic import BaseModel');

  const needsAny = entity.fields.some((f) => f.type === 'json');
  const needsLiteral = entity.fields.some((f) => f.type === 'enum');
  const needsDatetime = entity.fields.some((f) => f.type === 'date');
  const needsOptional = entity.fields.some((f) => f.required === false);

  const typing: string[] = [];
  if (needsAny) typing.push('Any');
  if (needsLiteral) typing.push('Literal');
  if (needsOptional) typing.push('Optional');
  if (typing.length) imports.add(`from typing import ${typing.join(', ')}`);
  if (needsDatetime) imports.add('from datetime import datetime');

  lines.push([...imports].join('\n'));
  lines.push('');
  lines.push('');
  lines.push(`class ${entity.name}(BaseModel):`);
  if (entity.description) lines.push(`    """${entity.description}"""`);
  lines.push(`    id: str`);

  for (const f of entity.fields) {
    const pyType = mapPythonType(f);
    if (f.required === false) {
      const def = f.default !== undefined ? ` = ${JSON.stringify(f.default)}` : ' = None';
      lines.push(`    ${f.name}: Optional[${pyType}]${def}`);
    } else {
      lines.push(`    ${f.name}: ${pyType}`);
    }
  }

  lines.push('');
  return lines.join('\n');
};
