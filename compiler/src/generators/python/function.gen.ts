import type { FunctionDef, FunctionStep } from '../../parsers/function.parser.js';

const HEADER = '# @generated by flusk-lang â€” DO NOT EDIT\n';

const mapPyType = (type: string): string => {
  const m: Record<string, string> = {
    string: 'str', number: 'int', boolean: 'bool', Database: 'Any',
  };
  if (type.endsWith('[]')) return `list[${mapPyType(type.slice(0, -2))}]`;
  return m[type] ?? type;
};

const genStep = (step: FunctionStep, indent: string): string => {
  const lines: string[] = [];

  if (step.call && !step.action) {
    const args = step.with
      ? Object.entries(step.with).map(([, v]) => (v.startsWith('$') ? v.slice(1) : `"${v}"`)).join(', ')
      : '';
    lines.push(`${indent}${step.id} = await ${step.call}(${args})`);
  } else if (step.action === 'filter' && step.where) {
    const src = step.source?.startsWith('$') ? step.source.slice(1) : step.source;
    const val = String(step.where.value);
    const valExpr = val.startsWith('$') ? val.slice(1) : `"${val}"`;
    const opMap: Record<string, string> = {
      eq: '==', neq: '!=', gt: '>', gte: '>=', lt: '<', lte: '<=',
    };
    const op = opMap[step.where.op] ?? '==';
    lines.push(`${indent}${step.id} = [x for x in ${src} if x.${step.where.field} ${op} ${valExpr}]`);
  } else if (step.action === 'forEach') {
    const src = step.source?.startsWith('$') ? step.source.slice(1) : step.source;
    const args = step.with
      ? Object.entries(step.with).map(([, v]) => (v === '$item' ? 'item' : v.startsWith('$') ? v.slice(1) : `"${v}"`)).join(', ')
      : 'item';
    lines.push(`${indent}for item in ${src}:`);
    if (step.onError === 'log-and-continue') {
      lines.push(`${indent}    try:`);
      lines.push(`${indent}        await ${step.call}(${args})`);
      lines.push(`${indent}    except Exception as e:`);
      lines.push(`${indent}        print(f"Error: {e}")`);
    } else {
      lines.push(`${indent}    await ${step.call}(${args})`);
    }
  } else if (step.action === 'return') {
    const val = step.source?.startsWith('$') ? step.source.slice(1) : step.source;
    lines.push(`${indent}return ${val}`);
  } else {
    lines.push(`${indent}# TODO: implement action "${step.action}" for step "${step.id}"`);
    lines.push(`${indent}pass`);
  }

  return lines.join('\n');
};

export const generatePythonFunction = (fn: FunctionDef): string => {
  const lines = [HEADER, 'from typing import Any\n'];
  const params = (fn.inputs ?? []).map((i) => `${i.name}: ${mapPyType(i.type)}`).join(', ');
  const retType = fn.output?.type ? mapPyType(fn.output.type) : 'None';
  lines.push(`async def ${fn.name}(${params}) -> ${retType}:`);
  if (fn.description) lines.push(`    """${fn.description}"""`);

  for (const step of fn.steps) {
    lines.push(genStep(step, '    '));
  }

  lines.push('');
  return lines.join('\n');
};
