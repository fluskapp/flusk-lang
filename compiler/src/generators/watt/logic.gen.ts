/**
 * Logic Code Generator — compiles Logic DSL AST to TypeScript
 *
 * Generates Fastify-compatible handler code that uses:
 * - Platformatic entity API (app.platformatic.entities.*)
 * - Built-in primitives (bcrypt, jwt, nanoid, etc.)
 * - Fastify reply for HTTP responses
 */

import type {
  LogicBlock, LogicNode, Expression,
  SetNode, AssertNode, IfNode, MapNode,
  EmitNode, ReturnNode, DbCallNode, PrimitiveCallNode,
} from '../../ast/logic.js';

const INDENT = '  ';

/** Map of entity names (kebab) to Platformatic table names (camelCase plural) */
const toEntityName = (s: string): string => {
  const camel = s.split(/[-_ ]+/)
    .map((w, i) => i === 0 ? w.toLowerCase() : w.charAt(0).toUpperCase() + w.slice(1).toLowerCase())
    .join('');
  return camel;
};

const toCamel = (s: string): string =>
  s.split(/[-_ ]+/)
    .map((w, i) => i === 0 ? w.toLowerCase() : w.charAt(0).toUpperCase() + w.slice(1).toLowerCase())
    .join('');

/** Detect which primitives are used so we can generate imports */
export const collectImports = (block: LogicBlock): Set<string> => {
  const imports = new Set<string>();
  const walk = (nodes: LogicNode[]): void => {
    for (const node of nodes) {
      if (node.kind === 'primitive') {
        const pn = node as PrimitiveCallNode;
        const lib = pn.name.split('.')[0]!;
        imports.add(lib);
      }
      if (node.kind === 'set') {
        walkExpr((node as SetNode).expression, imports);
      }
      if (node.kind === 'if') {
        const ifN = node as IfNode;
        walk(ifN.then);
        if (ifN.else) walk(ifN.else);
      }
      if (node.kind === 'map') {
        walk((node as MapNode).steps);
      }
    }
  };
  walk(block.steps);
  return imports;
};

const walkExpr = (expr: Expression, imports: Set<string>): void => {
  if (expr.type === 'call') {
    const lib = expr.name.split('.')[0]!;
    if (PRIMITIVE_MAP[expr.name] || PRIMITIVE_MAP[lib]) {
      imports.add(lib);
    }
    expr.args.forEach((a) => walkExpr(a, imports));
  }
  if (expr.type === 'binary') {
    walkExpr(expr.left, imports);
    walkExpr(expr.right, imports);
  }
  if (expr.type === 'unary') {
    walkExpr(expr.operand, imports);
  }
  if (expr.type === 'object') {
    Object.values(expr.properties).forEach((v) => walkExpr(v, imports));
  }
  if (expr.type === 'array') {
    expr.elements.forEach((e) => walkExpr(e, imports));
  }
};

/** Map primitive names to actual import code */
const PRIMITIVE_MAP: Record<string, string> = {
  hash: "import bcrypt from 'bcrypt';",
  verify: "import bcrypt from 'bcrypt';",
  bcrypt: "import bcrypt from 'bcrypt';",
  jwt: "// JWT handled via app.jwt (fastify-jwt plugin)",
  slugify: "const slugify = (s: string) => s.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-|-$/g, '');",
  nanoid: "import { nanoid } from 'nanoid';",
  apikey: "import { nanoid } from 'nanoid';",
  now: "// now() = new Date().toISOString()",
  crypto: "import { randomUUID, createHash } from 'node:crypto';",
};

/** Generate full function file from a logic block */
export const generateLogicFunction = (
  fnName: string,
  inputFields: { name: string; type: string }[],
  block: LogicBlock,
  featureName: string,
): string => {
  const imports = collectImports(block);
  const lines: string[] = [];

  // File header
  lines.push('// @generated by flusk-lang logic compiler');
  lines.push("import type { FastifyInstance, FastifyRequest, FastifyReply } from 'fastify';");
  lines.push('');

  // Primitive imports
  const importSet = new Set<string>();
  for (const lib of imports) {
    const imp = PRIMITIVE_MAP[lib];
    if (imp && !importSet.has(imp)) {
      lines.push(imp);
      importSet.add(imp);
    }
  }
  if (importSet.size > 0) lines.push('');

  // Input type
  if (inputFields.length > 0) {
    lines.push(`interface ${capitalize(fnName)}Input {`);
    for (const f of inputFields) {
      lines.push(`  ${toCamel(f.name)}: ${tsType(f.type)};`);
    }
    lines.push('}');
    lines.push('');
  }

  // Export the handler
  const safeName = fnName.includes('-') || fnName.includes('_') ? toCamel(fnName) : fnName;
  const inputType = inputFields.length > 0 ? `${capitalize(fnName)}Input` : 'unknown';
  lines.push(`export default async function ${safeName}(`);
  lines.push(`  app: FastifyInstance,`);
  lines.push(`  request: FastifyRequest,`);
  lines.push(`  reply: FastifyReply,`);
  lines.push(`  input: ${inputType},`);
  lines.push(`) {`);

  // Generate body
  const body = generateBlock(block, 1);
  lines.push(body);

  lines.push('}');
  lines.push('');

  return lines.join('\n');
};

/** Generate a route handler that parses input and calls logic */
export const generateLogicRouteHandler = (
  routeName: string,
  method: string,
  inputFields: { name: string; type: string }[],
  block: LogicBlock,
  featureName: string,
): string => {
  const fnName = toCamel(routeName);
  const base = generateLogicFunction(fnName, inputFields, block, featureName);

  // Replace the export signature with a Fastify route-compatible one
  return base;
};

const generateBlock = (block: LogicBlock, depth: number): string => {
  return block.steps.map((step) => generateStep(step, depth)).join('\n');
};

const generateStep = (node: LogicNode, depth: number): string => {
  const pad = INDENT.repeat(depth);

  switch (node.kind) {
    case 'set': {
      const n = node as SetNode;
      return `${pad}const ${n.variable} = ${emitExpr(n.expression)};`;
    }
    case 'assert': {
      const n = node as AssertNode;
      const lines = [
        `${pad}if (!(${emitExpr(n.condition)})) {`,
        `${pad}${INDENT}return reply.code(${n.statusCode}).send({ error: '${escStr(n.message)}' });`,
        `${pad}}`,
      ];
      return lines.join('\n');
    }
    case 'if': {
      const n = node as IfNode;
      const lines = [`${pad}if (${emitExpr(n.condition)}) {`];
      for (const step of n.then) {
        lines.push(generateStep(step, depth + 1));
      }
      if (n.else && n.else.length > 0) {
        lines.push(`${pad}} else {`);
        for (const step of n.else) {
          lines.push(generateStep(step, depth + 1));
        }
      }
      lines.push(`${pad}}`);
      return lines.join('\n');
    }
    case 'map': {
      const n = node as MapNode;
      const lines = [
        `${pad}const results = [];`,
        `${pad}for (const ${n.variable} of ${emitExpr(n.collection)}) {`,
      ];
      for (const step of n.steps) {
        lines.push(generateStep(step, depth + 1));
      }
      lines.push(`${pad}}`);
      return lines.join('\n');
    }
    case 'emit': {
      const n = node as EmitNode;
      const payloadParts = Object.entries(n.payload)
        .map(([k, v]) => `${k}: ${emitExpr(v)}`);
      return `${pad}app.emit('${toCamel(n.event)}', { ${payloadParts.join(', ')} });`;
    }
    case 'return': {
      const n = node as ReturnNode;
      return `${pad}return reply.send(${emitExpr(n.value)});`;
    }
    case 'db': {
      const n = node as DbCallNode;
      return `${pad}${emitDbCall(n)};`;
    }
    case 'primitive': {
      const n = node as PrimitiveCallNode;
      return `${pad}${emitPrimitive(n)};`;
    }
    default:
      return `${pad}// TODO: unknown logic node kind "${node.kind}"`;
  }
};

// --- Expression Emitter ---

const emitExpr = (expr: Expression): string => {
  switch (expr.type) {
    case 'literal':
      if (expr.value === null) return 'null';
      if (typeof expr.value === 'string') return `'${escStr(expr.value)}'`;
      return String(expr.value);

    case 'variable':
      return expr.name;

    case 'property':
      return `${emitExpr(expr.object)}.${expr.property}`;

    case 'call':
      return emitCallExpr(expr.name, expr.args);

    case 'binary':
      return `(${emitExpr(expr.left)} ${expr.op} ${emitExpr(expr.right)})`;

    case 'unary':
      return `${expr.op}(${emitExpr(expr.operand)})`;

    case 'object': {
      const props = Object.entries(expr.properties)
        .map(([k, v]) => {
          const val = emitExpr(v);
          return val === k ? k : `${k}: ${val}`;
        });
      return `{ ${props.join(', ')} }`;
    }

    case 'array':
      return `[${expr.elements.map(emitExpr).join(', ')}]`;

    case 'template':
      return '`' + expr.parts.map((p) =>
        typeof p === 'string' ? p : `\${${emitExpr(p)}}`
      ).join('') + '`';

    default:
      return '/* unknown expression */';
  }
};

/** Emit function call expressions — maps DSL names to real code */
const emitCallExpr = (name: string, args: Expression[]): string => {
  const a = args.map(emitExpr);

  switch (name) {
    // Auth primitives
    case 'hash':
      return `await bcrypt.hash(${a[0]}, 10)`;
    case 'verify':
      return `await bcrypt.compare(${a[0]}, ${a[1]})`;
    case 'jwt.sign':
      return `app.jwt.sign(${a[0]})`;
    case 'jwt.verify':
      return `app.jwt.verify(${a[0]})`;
    case 'apikey.generate':
      return `nanoid(${a[0] ?? 32})`;
    case 'slugify':
      return `slugify(${a[0]})`;
    case 'now':
      return `new Date().toISOString()`;
    case 'crypto.randomUUID':
      return `randomUUID()`;
    case 'crypto.hash':
      return `createHash('sha256').update(${a[0]}).digest('hex')`;

    // DB calls in expression context
    case 'db.findOne': {
      const entity = a[0]?.replace(/'/g, '');
      return `await app.platformatic.entities.${toEntityName(entity ?? '')}.find({ where: ${a[1] ?? '{}'}, limit: 1 }).then(r => r[0] ?? null)`;
    }
    case 'db.find': {
      const entity = a[0]?.replace(/'/g, '');
      return `await app.platformatic.entities.${toEntityName(entity ?? '')}.find({ where: ${a[1] ?? '{}'} })`;
    }
    case 'db.insert': {
      const entity = a[0]?.replace(/'/g, '');
      return `await app.platformatic.entities.${toEntityName(entity ?? '')}.save({ input: ${a[1] ?? '{}'} })`;
    }
    case 'db.update': {
      const entity = a[0]?.replace(/'/g, '');
      return `await app.platformatic.entities.${toEntityName(entity ?? '')}.save({ input: ${a[1] ?? '{}'} })`;
    }
    case 'db.delete': {
      const entity = a[0]?.replace(/'/g, '');
      return `await app.platformatic.entities.${toEntityName(entity ?? '')}.delete({ where: ${a[1] ?? '{}'} })`;
    }
    case 'db.count': {
      const entity = a[0]?.replace(/'/g, '');
      return `await app.platformatic.entities.${toEntityName(entity ?? '')}.count({ where: ${a[1] ?? '{}'} })`;
    }

    default:
      return `${name}(${a.join(', ')})`;
  }
};

/** Emit DB operation as statement */
const emitDbCall = (node: DbCallNode): string => {
  const entity = toEntityName(node.entity);
  const params = Object.entries(node.params)
    .map(([k, v]) => `${k}: ${emitExpr(v)}`);
  const paramsStr = params.length > 0 ? `{ ${params.join(', ')} }` : '{}';

  switch (node.op) {
    case 'find':
      return `await app.platformatic.entities.${entity}.find({ where: ${paramsStr} })`;
    case 'findOne':
      return `await app.platformatic.entities.${entity}.find({ where: ${paramsStr}, limit: 1 }).then(r => r[0] ?? null)`;
    case 'insert':
      return `await app.platformatic.entities.${entity}.save({ input: ${paramsStr} })`;
    case 'update':
      return `await app.platformatic.entities.${entity}.save({ input: ${paramsStr} })`;
    case 'delete':
      return `await app.platformatic.entities.${entity}.delete({ where: ${paramsStr} })`;
    case 'count':
      return `await app.platformatic.entities.${entity}.count({ where: ${paramsStr} })`;
    default:
      return `/* unknown db op: ${node.op} */`;
  }
};

/** Emit primitive call as statement */
const emitPrimitive = (node: PrimitiveCallNode): string => {
  const a = node.args.map(emitExpr);
  return emitCallExpr(node.name, node.args);
};

// --- Helpers ---

const capitalize = (s: string): string => {
  // If already camelCase, just uppercase first char
  if (!s.includes('-') && !s.includes('_') && !s.includes(' ')) {
    return s.charAt(0).toUpperCase() + s.slice(1);
  }
  const c = toCamel(s);
  return c.charAt(0).toUpperCase() + c.slice(1);
};

const escStr = (s: string): string =>
  s.replace(/'/g, "\\'").replace(/\n/g, '\\n');

const tsType = (t: string): string => {
  const map: Record<string, string> = {
    string: 'string', integer: 'number', number: 'number',
    float: 'number', boolean: 'boolean', date: 'string',
    datetime: 'string', json: 'unknown', object: 'Record<string, unknown>',
    array: 'unknown[]',
  };
  return map[t] ?? 'unknown';
};

/** Generate Platformatic authorization config from entity auth rules */
export const generateAuthConfig = (features: {
  entities: { name: string; fields: { name: string }[] }[];
  auth?: { jwt?: { secret: string }; rules?: unknown[] };
}[]): Record<string, unknown> => {
  const rules: unknown[] = [];

  // Auto-generate org-scoped rules for entities with org_id field
  for (const feature of features) {
    for (const entity of feature.entities) {
      const hasOrgId = entity.fields.some((f) => f.name === 'org_id');
      if (hasOrgId) {
        const tableName = entity.name.replace(/-/g, '_') + 's';
        rules.push({
          role: 'member',
          entity: tableName,
          find: { checks: { orgId: 'X-PLATFORMATIC-ORG-ID' } },
          save: { checks: { orgId: 'X-PLATFORMATIC-ORG-ID' } },
          delete: { checks: { orgId: 'X-PLATFORMATIC-ORG-ID' } },
          defaults: { orgId: 'X-PLATFORMATIC-ORG-ID' },
        });
        rules.push({
          role: 'admin',
          entity: tableName,
          find: { checks: { orgId: 'X-PLATFORMATIC-ORG-ID' } },
          save: { checks: { orgId: 'X-PLATFORMATIC-ORG-ID' } },
          delete: { checks: { orgId: 'X-PLATFORMATIC-ORG-ID' } },
          defaults: { orgId: 'X-PLATFORMATIC-ORG-ID' },
        });
      }
    }
  }

  return {
    jwt: { secret: '{JWT_SECRET}' },
    rules,
  };
};
