/**
 * Watt Test Generator — Platformatic-style integration tests
 * Uses platformatic/test helper for app injection
 */

import type { FeatureNode, FeatureEntity } from '../../ast/feature.js';

const HEADER = '// @generated by flusk-lang — DO NOT EDIT\n';

const toPascal = (s: string): string =>
  s.split(/[-_ ]+/).map((w) => w.charAt(0).toUpperCase() + w.slice(1)).join('');

const toCamel = (s: string): string => {
  const p = toPascal(s);
  return p.charAt(0).toLowerCase() + p.slice(1);
};

const toSnake = (s: string): string =>
  s.replace(/([a-z])([A-Z])/g, '$1_$2').toLowerCase().replace(/-/g, '_');

const toTableName = (s: string): string => toSnake(s) + 's';

export interface GeneratedTest {
  path: string;
  content: string;
}

/** Generate CRUD integration tests per entity (tests Platformatic DB endpoints) */
export const generateEntityCrudTests = (entity: FeatureEntity, feature: FeatureNode): GeneratedTest => {
  const name = toPascal(entity.name);
  const table = toTableName(entity.name);
  const lines: string[] = [HEADER];

  lines.push(`import { test } from 'node:test';`);
  lines.push(`import assert from 'node:assert/strict';`);
  lines.push(`import { buildServer } from '@platformatic/db';`);
  lines.push('');

  // Fixture data
  const fixture: Record<string, unknown> = {};
  for (const f of entity.fields) {
    if (f.type === 'string') fixture[f.name] = `test-${f.name}`;
    else if (f.type === 'number' || f.type === 'float') fixture[f.name] = 1;
    else if (f.type === 'boolean') fixture[f.name] = true;
    else if (f.type === 'enum' && f.values?.length) fixture[f.name] = f.values[0];
    else fixture[f.name] = `test`;
  }

  lines.push(`const fixture = ${JSON.stringify(fixture, null, 2)};`);
  lines.push('');

  lines.push(`test('${name} CRUD', async (t) => {`);
  lines.push(`  const app = await buildServer('./apps/db/platformatic.json');`);
  lines.push(`  await app.start();`);
  lines.push(`  const baseUrl = app.url;`);
  lines.push('');

  // CREATE
  lines.push(`  await t.test('POST /${table}', async () => {`);
  lines.push(`    const res = await fetch(\`\${baseUrl}/${table}\`, {`);
  lines.push(`      method: 'POST',`);
  lines.push(`      headers: { 'Content-Type': 'application/json' },`);
  lines.push(`      body: JSON.stringify(fixture),`);
  lines.push(`    });`);
  lines.push(`    assert.equal(res.status, 200);`);
  lines.push(`    const body = await res.json();`);
  lines.push(`    assert.ok(body.id);`);
  lines.push(`  });`);
  lines.push('');

  // READ
  lines.push(`  await t.test('GET /${table}', async () => {`);
  lines.push(`    const res = await fetch(\`\${baseUrl}/${table}\`);`);
  lines.push(`    assert.equal(res.status, 200);`);
  lines.push(`    const body = await res.json();`);
  lines.push(`    assert.ok(Array.isArray(body));`);
  lines.push(`    assert.ok(body.length > 0);`);
  lines.push(`  });`);
  lines.push('');

  // UPDATE
  lines.push(`  await t.test('PUT /${table}/1', async () => {`);
  lines.push(`    const res = await fetch(\`\${baseUrl}/${table}/1\`, {`);
  lines.push(`      method: 'PUT',`);
  lines.push(`      headers: { 'Content-Type': 'application/json' },`);
  const firstStringField = entity.fields.find((f) => f.type === 'string');
  if (firstStringField) {
    lines.push(`      body: JSON.stringify({ ${firstStringField.name}: 'updated' }),`);
  } else {
    lines.push(`      body: JSON.stringify(fixture),`);
  }
  lines.push(`    });`);
  lines.push(`    assert.equal(res.status, 200);`);
  lines.push(`  });`);
  lines.push('');

  // DELETE
  lines.push(`  await t.test('DELETE /${table}/1', async () => {`);
  lines.push(`    const res = await fetch(\`\${baseUrl}/${table}/1\`, { method: 'DELETE' });`);
  lines.push(`    assert.equal(res.status, 200);`);
  lines.push(`  });`);
  lines.push('');

  lines.push(`  await app.close();`);
  lines.push(`});`);
  lines.push('');

  return {
    path: `tests/${toCamel(entity.name)}.crud.test.ts`,
    content: lines.join('\n'),
  };
};

/** Generate custom route tests */
export const generateRouteTests = (feature: FeatureNode): GeneratedTest[] => {
  if (!feature.tests?.integration?.length) return [];

  const tests: GeneratedTest[] = [];

  for (const t of feature.tests.integration) {
    const lines: string[] = [HEADER];
    lines.push(`import { test } from 'node:test';`);
    lines.push(`import assert from 'node:assert/strict';`);
    lines.push(`import { buildServer } from '@platformatic/service';`);
    lines.push('');

    lines.push(`test('${feature.name} — ${t.name}', async () => {`);
    lines.push(`  const app = await buildServer('./apps/${feature.name}/platformatic.json');`);
    lines.push(`  await app.start();`);
    lines.push(`  const baseUrl = app.url;`);
    lines.push('');

    for (const step of t.steps) {
      if (step.type === 'auth') {
        lines.push(`  // Auth: ${step.target}`);
        lines.push('');
      } else if (['post', 'get', 'put', 'delete'].includes(step.type)) {
        const method = step.type.toUpperCase();
        lines.push(`  {`);
        lines.push(`    const res = await fetch(\`\${baseUrl}${step.path}\`, {`);
        lines.push(`      method: '${method}',`);
        if (step.body) {
          lines.push(`      headers: { 'Content-Type': 'application/json' },`);
          lines.push(`      body: JSON.stringify(${JSON.stringify(step.body)}),`);
        }
        lines.push(`    });`);
        if (step.expect?.status) {
          lines.push(`    assert.equal(res.status, ${step.expect.status});`);
        }
        lines.push(`  }`);
        lines.push('');
      } else if (step.type === 'wait') {
        lines.push(`  // Wait: ${step.target}`);
        lines.push(`  await new Promise((r) => setTimeout(r, 100));`);
        lines.push('');
      } else if (step.type === 'assert') {
        lines.push(`  // Assert: ${step.condition}`);
        lines.push('');
      }
    }

    lines.push(`  await app.close();`);
    lines.push(`});`);
    lines.push('');

    tests.push({
      path: `tests/${feature.name}-${t.name}.test.ts`,
      content: lines.join('\n'),
    });
  }

  return tests;
};

/** Generate all tests for a feature */
export const generateAllTests = (feature: FeatureNode): GeneratedTest[] => {
  return [
    ...feature.entities.map((e) => generateEntityCrudTests(e, feature)),
    ...generateRouteTests(feature),
  ];
};
