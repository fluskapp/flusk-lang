/**
 * Watt Plugin Generator — Fastify plugins with proper route wiring
 *
 * Each feature becomes one plugin file that:
 * 1. Registers custom routes (non-CRUD — Platformatic handles CRUD)
 * 2. Imports and calls logic functions
 * 3. Handles auth (JWT verification, API key check)
 * 4. Validates input with JSON Schema
 */

import type { FeatureNode, FeatureRoute, FeatureFunction } from '../../ast/feature.js';

const HEADER = '// @generated by flusk-lang — DO NOT EDIT\n';

const toCamel = (s: string): string => {
  const parts = s.split(/[-_ ]+/);
  return parts[0]! + parts.slice(1).map((w) => w.charAt(0).toUpperCase() + w.slice(1)).join('');
};

const toPascal = (s: string): string =>
  s.split(/[-_ ]+/).map((w) => w.charAt(0).toUpperCase() + w.slice(1)).join('');

const toJsonSchemaType = (t: string): string => {
  const map: Record<string, string> = {
    string: 'string', integer: 'integer', number: 'number',
    float: 'number', boolean: 'boolean', object: 'object',
    array: 'array', date: 'string', datetime: 'string',
  };
  return map[t] ?? 'string';
};

/** Generate a complete Fastify plugin for a feature */
export const generatePlugin = (feature: FeatureNode): string => {
  const lines: string[] = [HEADER];
  const name = toCamel(feature.name);

  lines.push("import type { FastifyInstance, FastifyRequest, FastifyReply } from 'fastify';");
  lines.push("import fp from 'fastify-plugin';");
  lines.push('');

  // Import logic functions (only those that have logic blocks or are referenced by routes)
  const logicFns = new Set<string>();
  for (const fn of feature.functions) {
    if (fn.logic && fn.logic.length > 0) {
      logicFns.add(toCamel(fn.name));
    }
  }
  // Routes that reference functions via actions.call
  for (const route of feature.routes) {
    logicFns.add(toCamel(route.name));
  }

  for (const fnName of logicFns) {
    lines.push(`import ${fnName} from '../functions/${fnName}.js';`);
  }
  lines.push('');

  lines.push(`export default fp(async (app: FastifyInstance) => {`);

  // Register routes
  for (const route of feature.routes) {
    lines.push('');
    lines.push(`  // ${route.method} ${route.path}`);

    const method = route.method.toLowerCase();
    const handler = toCamel(route.name);
    const hasBody = route.input && route.input.length > 0 && route.method !== 'GET';
    const hasQuery = route.input && route.input.length > 0 && route.method === 'GET';

    lines.push(`  app.${method}('${route.path}', {`);

    // JSON Schema validation
    if (hasBody) {
      const props: string[] = [];
      const required: string[] = [];
      for (const inp of route.input!) {
        props.push(`          ${toCamel(inp.name)}: { type: '${toJsonSchemaType(inp.type)}' }`);
        if (inp.required) required.push(`'${toCamel(inp.name)}'`);
      }
      lines.push(`    schema: {`);
      lines.push(`      body: {`);
      lines.push(`        type: 'object',`);
      lines.push(`        properties: {`);
      lines.push(props.join(',\n'));
      lines.push(`        },`);
      if (required.length > 0) {
        lines.push(`        required: [${required.join(', ')}],`);
      }
      lines.push(`      },`);
      lines.push(`    },`);
    }

    // Auth hooks
    if (route.auth === 'session') {
      lines.push(`    onRequest: [app.authenticate],`);
    } else if (route.auth === 'api-key') {
      lines.push(`    onRequest: [app.authenticateApiKey],`);
    }

    // Handler
    lines.push(`  }, async (request: FastifyRequest, reply: FastifyReply) => {`);

    if (hasBody) {
      lines.push(`    const input = request.body as Record<string, unknown>;`);
    } else if (hasQuery) {
      lines.push(`    const input = request.query as Record<string, unknown>;`);
    } else {
      lines.push(`    const input = {};`);
    }

    // Add params to input
    if (route.path.includes(':')) {
      lines.push(`    const params = request.params as Record<string, string>;`);
      lines.push(`    Object.assign(input, params);`);
    }

    // Add org context from JWT
    if (route.auth === 'session') {
      lines.push(`    const user = request.user as { sub: number; org: number; role: string };`);
      lines.push(`    Object.assign(input, { org_id: user.org, user_id: user.sub });`);
    }
    if (route.auth === 'api-key') {
      lines.push(`    Object.assign(input, { org_id: (request as any).orgId });`);
    }

    lines.push(`    return ${handler}(app, request, reply, input);`);
    lines.push(`  });`);
  }

  lines.push('');
  lines.push('});');
  lines.push('');

  return lines.join('\n');
};

/** Generate auth plugin — JWT verification + API key lookup */
export const generateAuthPlugin = (features: FeatureNode[]): string => {
  const lines: string[] = [HEADER];
  lines.push("import type { FastifyInstance, FastifyRequest, FastifyReply } from 'fastify';");
  lines.push("import fp from 'fastify-plugin';");
  lines.push("import fjwt from '@fastify/jwt';");
  lines.push('');
  lines.push('export default fp(async (app: FastifyInstance) => {');
  lines.push('');
  lines.push("  // Register JWT plugin");
  lines.push("  await app.register(fjwt, {");
  lines.push("    secret: process.env.JWT_SECRET || 'dev-secret',");
  lines.push("  });");
  lines.push('');
  lines.push('  // JWT auth decorator');
  lines.push('  app.decorate("authenticate", async (request: FastifyRequest, reply: FastifyReply) => {');
  lines.push('    try {');
  lines.push('      await request.jwtVerify();');
  lines.push('    } catch (err) {');
  lines.push("      return reply.code(401).send({ error: 'Unauthorized' });");
  lines.push('    }');
  lines.push('  });');
  lines.push('');
  lines.push('  // API key auth decorator (for desktop agents)');
  lines.push('  app.decorate("authenticateApiKey", async (request: FastifyRequest, reply: FastifyReply) => {');
  lines.push("    const apiKey = request.headers['x-api-key'] as string;");
  lines.push('    if (!apiKey) {');
  lines.push("      return reply.code(401).send({ error: 'API key required' });");
  lines.push('    }');
  lines.push('    const org = await app.platformatic.entities.organization.find({');
  lines.push("      where: { apiKey: { eq: apiKey } },");
  lines.push('      limit: 1,');
  lines.push('    });');
  lines.push('    if (!org || org.length === 0) {');
  lines.push("      return reply.code(401).send({ error: 'Invalid API key' });");
  lines.push('    }');
  lines.push('    (request as any).orgId = org[0].id;');
  lines.push('  });');
  lines.push('');
  lines.push('  // Health check');
  lines.push("  app.get('/status', async () => ({ status: 'ok', timestamp: new Date().toISOString() }));");
  lines.push('');
  lines.push('});');
  lines.push('');

  return lines.join('\n');
};

/** Generate a stub handler for routes without logic blocks */
export const generateRouteHandler = (route: FeatureRoute): string => {
  const lines: string[] = [HEADER];
  const name = toCamel(route.name);

  lines.push("import type { FastifyInstance, FastifyRequest, FastifyReply } from 'fastify';");
  lines.push('');
  lines.push(`export default async function ${name}(`);
  lines.push(`  app: FastifyInstance,`);
  lines.push(`  request: FastifyRequest,`);
  lines.push(`  reply: FastifyReply,`);
  lines.push(`  input: Record<string, unknown>,`);
  lines.push(`) {`);

  // Generate smart defaults based on route type
  if (route.loader) {
    // GET routes with a loader — query the entity
    const parts = route.loader.split('.');
    const entity = parts.length > 1 ? toCamel(parts[0]!) : toCamel(route.loader.replace(/-/g, ' '));
    lines.push(`  const orgId = input.org_id;`);
    lines.push(`  const data = await app.platformatic.entities.${entity}.find({`);
    lines.push(`    where: orgId ? { orgId: { eq: orgId } } : {},`);
    lines.push(`  });`);
    lines.push(`  return reply.send(data);`);
  } else if (route.actions?.length) {
    for (const action of route.actions) {
      if (action.type === 'create') {
        const entity = toCamel(action.target);
        lines.push(`  const result = await app.platformatic.entities.${entity}.save({`);
        lines.push(`    input: input as any,`);
        lines.push(`  });`);
        lines.push(`  return reply.send(result);`);
      } else if (action.type === 'update') {
        const entity = toCamel(action.target);
        lines.push(`  const result = await app.platformatic.entities.${entity}.save({`);
        lines.push(`    input: input as any,`);
        lines.push(`  });`);
        lines.push(`  return reply.send(result);`);
      } else if (action.type === 'delete') {
        const entity = toCamel(action.target);
        lines.push(`  await app.platformatic.entities.${entity}.delete({`);
        lines.push(`    where: { id: { eq: input.id ?? (input as any).${toCamel(route.path.split(':').pop() ?? 'id')} } },`);
        lines.push(`  });`);
        lines.push(`  return reply.send({ ok: true });`);
      } else if (action.type === 'emit') {
        lines.push(`  app.emit('${toCamel(action.target)}', input);`);
      } else if (action.type === 'validate') {
        lines.push(`  // Validation handled by JSON Schema in route config`);
      } else if (action.type === 'call') {
        lines.push(`  // TODO: call ${action.target}`);
      }
    }
    if (!route.actions.some((a) => a.type === 'create' || a.type === 'update' || a.type === 'delete')) {
      lines.push(`  return reply.send({ ok: true });`);
    }
  } else {
    lines.push(`  // TODO: implement ${name}`);
    lines.push(`  return reply.send({ ok: true });`);
  }

  lines.push('}');
  lines.push('');

  return lines.join('\n');
};

/** Generate a stub function (no logic block) */
export const generateFunction = (fn: FeatureFunction): string => {
  const lines: string[] = [HEADER];
  const name = toCamel(fn.name);

  lines.push("import type { FastifyInstance, FastifyRequest, FastifyReply } from 'fastify';");
  lines.push('');
  lines.push(`export default async function ${name}(`);
  lines.push(`  app: FastifyInstance,`);
  lines.push(`  request: FastifyRequest,`);
  lines.push(`  reply: FastifyReply,`);
  lines.push(`  input: Record<string, unknown>,`);
  lines.push(`) {`);

  if (fn.uses) {
    const [client, method] = fn.uses.split('.');
    lines.push(`  // External call: ${fn.uses}`);
    lines.push(`  return reply.send({ todo: '${fn.uses}' });`);
  } else {
    lines.push(`  // TODO: implement ${name}`);
    if (fn.description) lines.push(`  // ${fn.description}`);
    lines.push(`  return reply.send({ ok: true });`);
  }

  lines.push('}');
  lines.push('');

  return lines.join('\n');
};
