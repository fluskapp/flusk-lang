/**
 * Watt Event Generator — typed event system using Fastify decorators
 *
 * Strategy: Use Node.js EventEmitter decorated onto Fastify.
 * - Events are typed from YAML
 * - Handlers auto-registered as Fastify plugins
 * - Workers subscribe to events on startup
 * - No external deps (no Redis/Rabbit/Kafka)
 */

import type { FeatureNode, FeatureEvent, FeatureWorker } from '../../ast/feature.js';

const HEADER = '// @generated by flusk-lang — DO NOT EDIT\n';

const toCamel = (s: string): string => {
  const parts = s.split(/[-_ ]+/);
  return parts[0] + parts.slice(1).map((w) => w.charAt(0).toUpperCase() + w.slice(1)).join('');
};

const toPascal = (s: string): string =>
  s.split(/[-_ ]+/).map((w) => w.charAt(0).toUpperCase() + w.slice(1)).join('');

const toConst = (s: string): string =>
  s.replace(/([a-z])([A-Z])/g, '$1_$2').toUpperCase().replace(/-/g, '_');

/** Generate the event bus plugin — registers EventEmitter on Fastify */
export const generateEventBus = (feature: FeatureNode): string => {
  const lines: string[] = [HEADER];
  lines.push(`import { EventEmitter } from 'node:events';`);
  lines.push(`import { type FastifyInstance } from 'fastify';`);
  lines.push(`import fp from 'fastify-plugin';`);
  lines.push('');

  // Event name constants
  for (const event of feature.events) {
    lines.push(`export const ${toConst(event.name)} = '${event.name}';`);
  }
  lines.push('');

  // Payload types
  for (const event of feature.events) {
    const name = toPascal(event.name);
    lines.push(`export interface ${name}Payload {`);
    for (const p of event.payload) {
      const tsType = p.type === 'number' ? 'number' : p.type === 'boolean' ? 'boolean' : 'string';
      lines.push(`  ${p.name}: ${tsType};`);
    }
    lines.push(`}`);
    lines.push('');
  }

  // Typed emit/on helpers
  lines.push(`export interface FluskEvents {`);
  for (const event of feature.events) {
    lines.push(`  '${event.name}': ${toPascal(event.name)}Payload;`);
  }
  lines.push(`}`);
  lines.push('');

  lines.push(`export class FluskEventBus {`);
  lines.push(`  private emitter = new EventEmitter();`);
  lines.push('');
  lines.push(`  emit<K extends keyof FluskEvents>(event: K, payload: FluskEvents[K]): void {`);
  lines.push(`    this.emitter.emit(event, payload);`);
  lines.push(`  }`);
  lines.push('');
  lines.push(`  on<K extends keyof FluskEvents>(event: K, handler: (payload: FluskEvents[K]) => void | Promise<void>): void {`);
  lines.push(`    this.emitter.on(event, handler);`);
  lines.push(`  }`);
  lines.push('');
  lines.push(`  off<K extends keyof FluskEvents>(event: K, handler: (payload: FluskEvents[K]) => void | Promise<void>): void {`);
  lines.push(`    this.emitter.off(event, handler);`);
  lines.push(`  }`);
  lines.push(`}`);
  lines.push('');

  // Fastify plugin
  lines.push(`declare module 'fastify' {`);
  lines.push(`  interface FastifyInstance {`);
  lines.push(`    events: FluskEventBus;`);
  lines.push(`  }`);
  lines.push(`}`);
  lines.push('');

  lines.push(`export default fp(async (app: FastifyInstance) => {`);
  lines.push(`  const bus = new FluskEventBus();`);
  lines.push(`  app.decorate('events', bus);`);
  lines.push(`  app.log.info('Event bus registered');`);
  lines.push(`});`);
  lines.push('');

  return lines.join('\n');
};

/** Generate event handler/subscriber plugin */
export const generateEventHandlers = (feature: FeatureNode): string => {
  const lines: string[] = [HEADER];
  lines.push(`import { type FastifyInstance } from 'fastify';`);
  lines.push(`import fp from 'fastify-plugin';`);

  // Import event constants and payload types
  const eventNames = feature.events.map((e) => toConst(e.name));
  const payloadTypes = feature.events.map((e) => `${toPascal(e.name)}Payload`);
  lines.push(`import { ${[...eventNames, ...payloadTypes].join(', ')} } from './event-bus.js';`);
  lines.push('');

  // Build event→worker map from triggers
  const eventWorkerMap = new Map<string, string[]>();
  for (const event of feature.events) {
    const workers = (event.triggers ?? [])
      .filter((t) => t.type === 'worker')
      .map((t) => t.target);
    if (workers.length > 0) {
      eventWorkerMap.set(event.name, workers);
    }
  }

  // Import worker handlers
  const workerNames = new Set<string>();
  for (const workers of eventWorkerMap.values()) {
    for (const w of workers) workerNames.add(w);
  }
  for (const w of workerNames) {
    lines.push(`import { ${toCamel(w)} } from '../workers/${toCamel(w)}.js';`);
  }
  lines.push('');

  lines.push(`export default fp(async (app: FastifyInstance) => {`);

  for (const event of feature.events) {
    const workers = eventWorkerMap.get(event.name) ?? [];
    const constName = toConst(event.name);
    const payloadType = `${toPascal(event.name)}Payload`;

    lines.push('');
    lines.push(`  // ${event.name}`);
    lines.push(`  app.events.on(${constName}, async (payload: ${payloadType}) => {`);
    lines.push(`    app.log.info({ event: ${constName}, payload }, 'Event received');`);

    for (const worker of workers) {
      lines.push(`    try {`);
      lines.push(`      await ${toCamel(worker)}(app.platformatic, payload);`);
      lines.push(`    } catch (err) {`);
      lines.push(`      app.log.error({ err, worker: '${worker}' }, 'Worker failed');`);
      lines.push(`    }`);
    }

    lines.push(`  });`);
  }

  lines.push(`});`);
  lines.push('');

  return lines.join('\n');
};

/** Generate worker function files */
export const generateWorker = (worker: FeatureWorker, feature: FeatureNode): string => {
  const lines: string[] = [HEADER];
  const name = toCamel(worker.name);

  lines.push(`import type { PlatformaticApp } from '@platformatic/db';`);
  lines.push('');

  lines.push(`export const ${name} = async (`);
  lines.push(`  platformatic: PlatformaticApp,`);
  lines.push(`  payload: Record<string, unknown>,`);
  lines.push(`): Promise<void> => {`);

  for (const step of worker.steps) {
    if (step.type === 'load') {
      const entity = toCamel(step.target);
      lines.push(`  const ${entity} = await platformatic.entities.${entity}.find({`);
      lines.push(`    where: { id: { eq: payload.${entity}_id ?? payload.id } },`);
      lines.push(`    limit: 1,`);
      lines.push(`  }).then((r: unknown[]) => r[0]);`);
    } else if (step.type === 'call') {
      lines.push(`  // Call: ${step.target}`);
      lines.push(`  // TODO: wire to function`);
    } else if (step.type === 'update') {
      const parts = step.target.split('.');
      const entity = toCamel(parts[0]);
      lines.push(`  await platformatic.entities.${entity}.save({`);
      lines.push(`    input: { ...payload },`);
      lines.push(`  });`);
    } else if (step.type === 'emit') {
      lines.push(`  // Emit: ${step.target}`);
    }
  }

  lines.push(`};`);
  lines.push('');

  return lines.join('\n');
};
