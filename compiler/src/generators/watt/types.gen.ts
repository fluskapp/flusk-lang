/**
 * Watt Types Generator — TypeScript types from entity definitions
 * Platformatic generates types from DB, but we also generate from YAML
 * for use before DB exists (e.g., SDK, frontend, tests)
 */

import type { FeatureNode, FeatureEntity, FeatureField } from '../../ast/feature.js';

const HEADER = '// @generated by flusk-lang — DO NOT EDIT\n';

const toPascal = (s: string): string =>
  s.split(/[-_ ]+/).map((w) => w.charAt(0).toUpperCase() + w.slice(1)).join('');

const tsType = (field: FeatureField): string => {
  const map: Record<string, string> = {
    string: 'string', number: 'number', boolean: 'boolean',
    date: 'string', datetime: 'string', json: 'Record<string, unknown>',
    float: 'number', 'string[]': 'string[]',
  };
  if (field.type === 'enum' && field.values) {
    return field.values.map((v) => `'${v}'`).join(' | ');
  }
  return map[field.type] ?? 'unknown';
};

/** Generate entity interface */
export const generateEntityType = (entity: FeatureEntity): string => {
  const name = toPascal(entity.name);
  const lines: string[] = [HEADER];

  lines.push(`export interface ${name} {`);
  lines.push(`  id: number;`);
  for (const f of entity.fields) {
    const opt = f.nullable || f.default !== undefined ? '?' : '';
    lines.push(`  ${f.name}${opt}: ${tsType(f)};`);
  }
  lines.push(`  createdAt: string;`);
  lines.push(`  updatedAt: string;`);
  lines.push(`}`);
  lines.push('');

  // Create input (omit id + timestamps)
  lines.push(`export interface ${name}Create {`);
  for (const f of entity.fields) {
    const opt = !f.required || f.default !== undefined ? '?' : '';
    lines.push(`  ${f.name}${opt}: ${tsType(f)};`);
  }
  lines.push(`}`);
  lines.push('');

  // Update input (all optional)
  lines.push(`export interface ${name}Update {`);
  for (const f of entity.fields) {
    lines.push(`  ${f.name}?: ${tsType(f)};`);
  }
  lines.push(`}`);
  lines.push('');

  return lines.join('\n');
};

/** Generate barrel types file for all entities in a feature */
export const generateFeatureTypes = (feature: FeatureNode): string => {
  const lines: string[] = [HEADER];

  for (const entity of feature.entities) {
    const name = toPascal(entity.name);
    lines.push(`export type { ${name}, ${name}Create, ${name}Update } from './${name}.js';`);
  }
  lines.push('');

  return lines.join('\n');
};
