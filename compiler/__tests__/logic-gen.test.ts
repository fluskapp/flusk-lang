import { describe, it, expect } from 'vitest';
import { parseLogicBlock } from '../src/parsers/logic.parser.js';
import { generateLogicFunction, collectImports } from '../src/generators/watt/logic.gen.js';

describe('Logic Generator', () => {
  it('generates set statements', () => {
    const block = parseLogicBlock(['set: slug = slugify(input.org_name)']);
    const code = generateLogicFunction('test', [], block, 'test');
    expect(code).toContain('const slug = slugify(input.org_name)');
  });

  it('generates assert with reply.code', () => {
    const block = parseLogicBlock([{
      assert: 'found',
      status: 404,
      message: 'Not found',
    }]);
    const code = generateLogicFunction('test', [], block, 'test');
    expect(code).toContain('if (!(found))');
    expect(code).toContain('reply.code(404)');
    expect(code).toContain('Not found');
  });

  it('generates if/else blocks', () => {
    const block = parseLogicBlock([{
      if: '!tool',
      then: ['set: created = true'],
      else: ['set: created = false'],
    }]);
    const code = generateLogicFunction('test', [], block, 'test');
    expect(code).toContain('if (!(tool))');
    expect(code).toContain('} else {');
  });

  it('generates emit statements', () => {
    const block = parseLogicBlock(['emit: org-created, { org_id: org.id }']);
    const code = generateLogicFunction('test', [], block, 'test');
    expect(code).toContain("app.emit('orgCreated'");
  });

  it('generates return with reply.send', () => {
    const block = parseLogicBlock(['return: { token, org }']);
    const code = generateLogicFunction('test', [], block, 'test');
    expect(code).toContain('return reply.send({ token, org })');
  });

  it('generates hash primitive with bcrypt import', () => {
    const block = parseLogicBlock(['set: hashed = hash(input.password)']);
    const code = generateLogicFunction('test', [], block, 'test');
    expect(code).toContain("import bcrypt from 'bcrypt'");
    expect(code).toContain('await bcrypt.hash(input.password, 10)');
  });

  it('generates jwt.sign call', () => {
    const block = parseLogicBlock(['set: token = jwt.sign({ sub: member.id })']);
    const code = generateLogicFunction('test', [], block, 'test');
    expect(code).toContain('app.jwt.sign');
  });

  it('generates apikey.generate with nanoid', () => {
    const block = parseLogicBlock(['set: key = apikey.generate()']);
    const code = generateLogicFunction('test', [], block, 'test');
    expect(code).toContain("import { nanoid } from 'nanoid'");
    expect(code).toContain('nanoid(');
  });

  it('generates db.findOne with Platformatic entity API', () => {
    const block = parseLogicBlock([
      'set: existing = db.findOne(organization, { slug })',
    ]);
    const code = generateLogicFunction('test', [], block, 'test');
    expect(code).toContain('app.platformatic.entities.organization.find');
    expect(code).toContain('limit: 1');
  });

  it('generates db.insert as statement', () => {
    const block = parseLogicBlock([
      'db.insert: organization, { name: input.name }',
    ]);
    const code = generateLogicFunction('test', [], block, 'test');
    expect(code).toContain('app.platformatic.entities.organization.save');
    expect(code).toContain('input:');
  });

  it('generates input type interface', () => {
    const block = parseLogicBlock(['return: input']);
    const code = generateLogicFunction('registerOrg', [
      { name: 'org_name', type: 'string' },
      { name: 'email', type: 'string' },
    ], block, 'organizations');
    expect(code).toContain('interface RegisterOrgInput');
    expect(code).toContain('orgName: string');
    expect(code).toContain('email: string');
  });

  it('generates map loop', () => {
    const block = parseLogicBlock([{
      map: 'span in input.spans',
      steps: ['set: provider = span.provider'],
    }]);
    const code = generateLogicFunction('test', [], block, 'test');
    expect(code).toContain('for (const span of input.spans)');
  });

  it('generates full register-org function', () => {
    const block = parseLogicBlock([
      'set: slug = slugify(input.org_name)',
      { assert: '!db.findOne(organization, { slug })', status: 409, message: 'Org already exists' },
      'set: password_hash = hash(input.password)',
      'set: api_key = apikey.generate()',
      'emit: org-created, { org_id: org.id }',
      'return: { token, org }',
    ]);
    const code = generateLogicFunction('registerOrg', [
      { name: 'org_name', type: 'string' },
      { name: 'email', type: 'string' },
      { name: 'password', type: 'string' },
      { name: 'name', type: 'string' },
    ], block, 'organizations');

    // Should have proper structure
    expect(code).toContain('// @generated by flusk-lang logic compiler');
    expect(code).toContain("import bcrypt from 'bcrypt'");
    expect(code).toContain("import { nanoid } from 'nanoid'");
    expect(code).toContain('interface RegisterOrgInput');
    expect(code).toContain('export default async function registerOrg');
    expect(code).toContain('slugify(input.org_name)');
    expect(code).toContain('await bcrypt.hash(input.password, 10)');
    expect(code).toContain('nanoid(');
    expect(code).toContain("app.emit('orgCreated'");
    expect(code).toContain('return reply.send');
  });

  it('collects correct imports', () => {
    const block = parseLogicBlock([
      'set: h = hash(input.pw)',
      'set: k = apikey.generate()',
      'set: t = jwt.sign({ sub: 1 })',
    ]);
    const imports = collectImports(block);
    expect(imports.has('hash')).toBe(true);
    expect(imports.has('apikey')).toBe(true);
    expect(imports.has('jwt')).toBe(true);
  });
});
